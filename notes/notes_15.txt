Mechanism: Address Translation

Limited direct execution (or LDE)
    Let program run directly on hardware
    Make sure OS ensures right thing happens (such as when a process issues a system call, or a timer interrupt occurs)

Efficiency:
    Hardware support
    TLBs
    Page-table support

Control:
    No application is allowed to access any memory but its own
    Protect applications from one another
    Portect OS from applications

Flexibility:
    Use their address spaces whatever they like

Hardware-based address translation
    Hardware transforms each memory access
    Changed virtual address to a physical address

15.1 Assumptions
    User's address space must be placed contiguously in physical memory
    Size of address space is not too big (less than the size of physical memory)
    Each address space is exactly the same size

15.2 An Example
    void func() {
        int x;
        x = x + 3; // this is the line of code we are interested in
    }

    The compiler turns this code into assembly
        128: movl 0x0(%ebx), %eax       ; load 0+ebx into eax
        132: addl $0x03, %eax           ; add 3 to eax register
        135: movl %eax, 0x0(%ebx)       ; store eax back to mem
            Presumes the address of x has been placed in the register ebx
            Loads the value of address into eax
            Adds 3 to eax
            Stores value in eax back into memory

    Perspective of process:
        Fetch instruction at address 128
        Execute this instruction (load from address 15 KB)
        Fetch instruction at address 132
        Execute this instruction (no memory reference)
        Fetch the instruction at address 135
        Execute this instruction (store to address 15 KB)

        Address space starts at 0 and grows to a maximum of 16 KB
            All memory references should be within these bounds

15.3 Dynamic (Hardware-based) Relocation
    Base and Bounds/Dynamic Relocation
    Need 2 hardware registers within each CPU
        Base register
        Bounds register (also known as the limits register)
            The pair of registers allow us to place the address space anywhere in the physical memory while nesuring that each process can only access its own address space

    When program starts running, OS decides where in the physical memory it should be loaded and sets the base register to that value
        physical address = virtual address + base
        Example:
            128: movl 0x0(%ebx), %eax
            PC is set to 128
            Base register is set to 32 KB (32768)
            Therefore, physical address is 128+32768 = 32896
        Everytime the process executes an instruction, it adds the base register value to the value of the program counter

    The bounds register is used for protection
        Processor will check the memory reference is within bounds to make sure it is legal
        If process generates a virtual address that is greater than the bounds or one that is negative, CPU will raise an exception and the process will be terminated
    Bounds register also "holds the size of address space"
        Also holds the physical address of the end of the address space

    Memory Management Unit (MMU) - part of the processor that helps with address translation

    Example:
        Process with address space of size 4 KB
            Virtual address          Physical address
                          0  ->                 16 KB
                       1 KB  ->                 17 KB
                       3000  ->                 19384
                       4400  -> Fault (out of bounds)

15.4 Hardware Support: A Summary
    OS runs in privilege mode (kernel mode)
        Has access to entire machine
    Applications run in user mode
        Limited in what they can do
    Hardware must provide base and bounds registers
    Each CPU has an additional pair of registers (part of the MMU of the CPU)
    When program is running, hardware will translate each address by adding the base value to the virtual address generated by the program
    Hardware must check whether address is valid
    Hardware should provide special instructions (privilged) to modify the base and bounds registers for different processes.
    CPU must be able to generate exceptions
        Program tries to access memory illegally
            CPU stops executing the program
            Arrange for an "out-of-bounds" exception handler
        Program tries to change the values of the base and bounds register
            CPU stops executing the program
            Arrange for a "tried to execute a privileged operation while in user mode" handler
        Must provide a method to inform location of handlers

Hardware Requirements
    Privileged mode
        Needed to prevent user-mode processes from executing privileged operations
    Base/bounds registers
        Need pair of regsiters per CPU to support address translation and bounds checks
    Ability to translate virtual addresses and check if within bounds
        Circuitry to do translations and check limits; in this case, quite simple
    Privilieged instruction(s) to update base/bounds
        OS must be able to set these values before letting a user program run
    Privileged instruction(s) to register exception handlers
        OS must be able to tell hardware what code to run if exception occurs
    Ability to raise exceptions
        When processes try to access privileged instructions or out-of-bounds memory

15.5 Operating System Issues
    OS must find space for for the process' address space in memory
        When new process is created, OS will search a data structure (called a free list) for the new address space
    OS will do work when a process is terminated
        Types of process termination:
            Exit properly
            Forcefully killed
        OS should reclaim all of its memory and put it back on the free list
        Clean up any associated data structures
    When context switch occurs, the OS must
        Save and restore the base-and-bounds pair
            Must save to memory if process is stopped running
                Saved in process structure/process control block (PCB)
        Set the values of base and bounds on CPU when running a process

        To move process' address space, the OS
            Deschedules the process
            Copies address space from current location to new location
            Updates the saved base register to point to new location
            The process will not now that its instructions and data are now in a completely new spot in (physical) memory
    OS must provide exception handlers (installed at boot time)
        If process tried to access memory outside its bounds, CPU will raise an exception
            OS must be prepared to react
                Usually terminates the process
        Should be protective of the machine

Limited Direct Execution Protocol (Dynamic Relocation)
OS @ boot (kernel mode)
Hardware
Program (user mode)

    OS
        Initialize trap table
    Hardware
        Remember addresses of:
            System call handler
            Timer handler
            Illegal memory access handler
            Illegal instruction handler
    OS
        Start interrupt timer
    Hardware
        Start timer; interrupt after X ms
    OS
        Initialize process table, initialize free list

To start process A:
    OS
        Allocates entry in process table
        Allocates memory for process
        Sets base/bounds registers
        Return-from-trap (into A)
    Hardware 
        Restore registers of A
        Moves to user mode
        Jump to A's (initial) PC
    Program
        Process A runs
        Fetch instruction
    Hardware
        If explicit load/store:
            Ensure address is in-bounds;
            Translate virtual address and perform load/store
    Program
        Continues running
    Hardware
        Timer interrupt
        Move to kernel mode
        Jump to interrupt handler
    OS
        Handle the trap
            Call switch() routine
            Save registers(A) to process-structure(A)
                (including base/bounds)
            Restore registers(B) to process-structure(B)
                (including base/bounds)
            Return-from-trap (into B)
    Hardware
        Restore registers of B
        Move to user mode
        Jump to B's PC
    Program
        Process B runs
        Execute bad load
    Hardware
        Load is out-of-bounds;
        Move to kernel mode
        Jump to trap handler
    OS
        Handle the trap
        Decide to terminate process B
        Deallocate B's memory
        Free B's entry in process table

15.6 Summary
    Internal fragmentation - Space inside the allocated unit is not all used (fragmented) and thus wasted
        Happens when stack and heap do not take up a lot of memory