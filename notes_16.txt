Segmentation

16.1 Segmentation: Generalized Base/Bounds
    Instead of having one base/bounds pair in the MMU, should have base/bounds pair per logical segment of the address space
    We have three segments
        Code
        Stack
        Heap
    Segmentation allows the OS to place the segments independently in different parts of the physical memory
    Only used memory is allocated space

    Segment     Base    Size
    Code       32 KB    2 KB
    Heap       34 KB    2 KB
    Stack      28 KB    2 KB

    Example:
        Reference made to virtual address 100 (code segment)
            Add base value to offset (100 + 32 KB)
        Check if address is within bounds (100 < 2 KB

        Reference made to virtual address 4200 (heap segment)
            Extract offset into heap
                Heap starts at 4 KB, so offset of 4200 is actually 104 (4 KB - 4200)
            Then add base value to offset (104 + 34 KB)

        If reference made to an illegal address,
            Hardware detects the address is out of bounds
            Traps into the OS
            Terminates process
        SEGMENTATION FAULT

16.2 Which Segment Are We Referring To?
    Explicit Approach
        Divide address space into segments based on top few bits of virtual address
        We have three segments
            Need two bits
                Top two bits of 14-bit virtual address to select segment
                If top two bits are 00, hardware knows its code segment
                If top two bits are 01, hardware knows its heap segment
        Hardware uses first two bits to determine which segment register to use
        Then uses next 12 bits as offset into the segment

        Sample code:
            // get top 2 bits of 14-bit VA
            Segment = (VirtualAddress & SEG_MASK) >> SEG_SHIFT
            // now get offset
            Offset  = VirtualAddress & OFFSET_MASK
            if (Offset >= Bounds[Segment])
                RaiseException(PROTECTION_FAULT)
            else
                PhysAddr = Base[Segment] + Offset
                Register = AccessMemory(PhysAddr)

            Where
                SEG_MASK = 0x3000
                OFFSET_MASK = 0xFFF
                SEG_SHIFT = 12

        Using two bits for 3 segments means one segment goes unsued
            Some systems put code in the same segment as heap
                Thus only use one bit to select which segment to use

    Implicit Approach
        Hardware determines the segment by seeing how the address was formed
            If generated by program counter, then address is within code segment
            If based off stack/base pointer, it must be in stack segment
            Otherwise, it must be in the heap segment

16.3 What About The Stack?
    Stack grows backwards
        Because of this, we need extra hardware support to determine which way a segment grows
            1 for growing in the positive direction
            0 for growing in the negative direction

        Segment     Base    Size    Grows Positive?
        Code       32 KB    2 KB           1
        Heap       34 KB    2 KB           1
        Stack      28 KB    2 KB           0

    Example:
        Access virtual address 15 KB, which should map to physical address 27 KB
        Virtual address is 11 1100 0000 0000 (0x3C00)
        Hardware uses top two bits to designate the segment
        Left with offset of 3 KB.
        To obtain correct negative offset,
            Subtract a slightly larger segment size from 3 KB
                Segment size can be 4 KB
                3 KB - 4 KB = -1 KB
        Add negative offset to the base
            -1 KB + 28 KB = 27 KB

16.4 Support for Sharing
    Protection bits
        Sample output of "ls -al" at /Users/fwedeorange/2016F/COM SCI 111
            drwxr-xr-x  21 fwedeorange  admin      714 Dec  3 01:38 .
            drwxr-xr-x   7 fwedeorange  admin      238 Oct 10 01:39 ..
            -rw-r--r--@  1 fwedeorange  admin    14340 Dec  2 00:43 .DS_Store
            -rw-r--r--@  1 fwedeorange  admin  6691589 Oct 24 16:38 CS111-1.pdf
            drwxr-xr-x  11 fwedeorange  admin      374 Oct 23 13:14 Lecture Slides
            -rw-r--r--@  1 fwedeorange  admin  2251145 Oct 24 16:38 cs111.pdf
            -rw-r--r--@  1 fwedeorange  admin  3859980 Oct 24 11:25 cs111_midterm.pdf
            drwxr-xr-x  11 fwedeorange  admin      374 Oct  5 16:35 lab0
            drwxr-xr-x   8 fwedeorange  admin      272 Oct 12 22:45 lab1a
            drwxr-xr-x  10 fwedeorange  admin      340 Oct 13 00:59 lab1b
            drwxr-xr-x  14 fwedeorange  admin      476 Nov  1 22:36 lab2a
            drwxr-xr-x  11 fwedeorange  admin      374 Nov  3 23:07 lab2b
            drwxr-xr-x  10 fwedeorange  admin      340 Nov 22 13:12 lab3a
            drwxr-xr-x  12 fwedeorange  admin      408 Nov 30 01:35 lab3b
            drwxr-xr-x  32 fwedeorange  admin     1088 Dec  3 02:19 textbook

            Columns:
                Permissions
                Number of links
                User/Owner name
                User/Owner group
                File size
                Date last modified
                File/directory name

            Permissions
                First letter
                    d for directory
                    - for regular file
                    l for symbolic link
                Three sets of permissions
                    r for read
                    w for write
                    x for execute
                    - for cannot read/write/execute

                    1st set for user/owner
                    2nd set for group
                    3rd set for world/other

    Basic support adds a few bits per segment
        Whether it can read/write a segment or execute code that lies in the segment

    Read-only
        Same code can be shared across multiple process
        No worry of harming isolation
        Each process thinks it's accesing its own private memory
            OS is secretly sharing memory which cannot be modified by the process

16.5 Fine-grained vs. Coarse-grained Segmentation
    Systems with just a few segments (i.e., code, stack, heap) is referred to as coarse-grained segmentation
    Systems with a large number of smaller segments is referred to as fine-grained segmentation
        Requires
            Further hardware support
            Segment table
        By having fine-grained segments, the OS would utilize main memory more effectively because it'll know which segments are in use and which are not

16.6 OS Support
    External fragmentation
        Physical memory quickly becomes full of little holes of free space
            Difficult to
                Allocate new segments
                Grow existing segments
    Solution to external fragmentation
        Compact physical memory by rearranging the existing segments
            OS stop whichever processes are running
            Copy their data to one contiguous region of memory
            Change segment register values to point to new locations
            
            Compaction is expensive
                Memory-intensive
                Uses a fair amount of processor time
        Free-list management algorithm
            Best-fit
                Keeps a list of free spaces and returns the one closest in size that satisfies the deisred allocation to the requester
            Worst-fit
            First-fit
            Buddy algorithm
    External fragmentation will exist no matter what
        A good and smart algorithm can only minimize it

QUESTIONS!
Page 154
    To obtain the correct negative offset, we must subtract the maximum segment size from 3KB: in this example, a segment can be 4KB, and thus the correct negative offset is 3KB minus 4KB which equals -1KB. We simply add the negative offset (-1KB) to the base (28KB) to arrive at the correct physical address: 27KB. The bounds check can be calculated by ensuring the absolute value of the negative offset is less than the segmentâ€™s size.